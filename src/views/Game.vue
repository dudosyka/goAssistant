<template>
    <div class="home">
        <div style="text-align: center;">
            <div class="section w3-text-white" style="width:300px;display:inline-block;">
                <div class="moveDiv">&#9899; <b id="blackPlayerName" class="textLimiter">{{localeData.loading}}</b><span class="time-icon ns">‚è≥</span><span id="blackTimer" class="ns">--:--</span></div>
                <div class="moveDiv">&#9898; <b id="whitePlayerName" class="textLimiter">{{localeData.loading}}</b><span class="time-icon ns">‚è≥</span><span id="whiteTimer" class="ns">--:--</span></div>
            </div><br class="ns">
            <div id="game" class="gobanTexture"></div><br class="ns">
            <button class="w3-button w3-white w3-hover-white tr" id="passButton">{{localeData.pass}}</button>
            <button class="w3-button w3-white w3-hover-white tr" id="resignButton">{{localeData.resign}}</button><br class="ns">
            <span id="specialMessages"></span>
        </div>

        <div class="w3-sidebar w3-bar-block w3-white" style="width:300px;left:0;top:0px;line-height:2;overflow:hidden;">
            <div class="w3-container w3-card-2 w3-center" style="padding: 10px">GoAssistant</div>

            <div class="bar" style="overflow:auto;padding-bottom:40px">

              <div class="section">
                <span class="opposite"><div>{{localeData.onBoard}}: </div><b id="blockCount">0</b></span>
                <div style="margin-top:10px;margin-bottom:10px">
                    <div>{{localeData.spentScore}} </div>
                    <span class="opposite"><div>&#9899; <b id="blackHints">0</b> {{localeData.score}}</div><div><b id="whiteHints">0</b> {{localeData.score}} &#9898;</div></span>
                </div>
                <span class="opposite"><div>{{stage}} {{localeData.gameStage}} </div><b id="gameStage">N/A</b></span>
              </div>

                <span id="recommendedHelpersLabel"><span class="icon">üí°</span> {{localeData.recommended}}</span>
                <div id="recommendedHelpers">
                </div><br class="ns">
                <button class="w3-button main_color w3-hover-black tr helperButton" id="allHelpersButton">{{localeData.allHelpers}}</button>
                <div id="allHelpers" style="display: none">
                </div>
            </div>
        </div>
        <div style="right:0;top:0;position:absolute;">
            <button class="w3-button w3-card-4 tr w3-text-white w3-large" onclick="document.getElementById('gameStoryBar').style.display = 'block'">‚ò∞ {{localeData.historyShort}}</button>
        </div>
        <div class="w3-sidebar w3-bar-block w3-white w3-animate-right" style="width:270px;right:0;top:0px;overflow:hidden;display:none" id="gameStoryBar">
            <div class="w3-container w3-card-4 w3-center" style="padding: 10px">
                {{localeData.history}}
                <span onclick="document.getElementById('gameStoryBar').style.display='none'" class="w3-button w3-display-topright tr">&times;</span>
            </div>
            <div id="moveHistory" style="overflow: auto;max-height: calc(100% - 25px);padding-bottom:18px;"></div>
        </div>

        <div id="modal" class="w3-modal">
            <div class="w3-modal-content w3-animate-top w3-card-4">
                <header class="w3-container w3-purple">
                    <h2 id="modalHeader">-</h2>
                </header>
            <div class="w3-container">
                <p id="modalText">Some text..</p>
            </div>
            <footer class="w3-container w3-purple" id="modalFooter"></footer>
          </div>
        </div>
    </div>
</template>

<style>
    @import "../assets/styles/board.css";
    @import "../assets/styles/side.css";
    @import "../assets/styles/pallete.css";
</style>

<script>
import { w3cwebsocket as W3CWebSocket } from "websocket";
import * as Hint from "../Models/Hint";
import * as Localization from "../Models/Localization";

export default {
    name: 'Home',
    components: {},
    data() {
        return {
            game: null,
            client: null,
            locale: null,
            stage: 'üü¢',
            localeData: {
                loading: "",
                pass: "",
                resign: "",
                onBoard: "",
                spentScore: "",
                score: "",
                gameStage: "",
                recommended: "",
                allHelpers: "",
                historyShort: "",
                history: ""
            }
        }
    },
    methods: {
        async loadGame() {
            return get('/game/info/' + storage('curGameId') + "?token=" + storage('token'), null, data => {
                return data;
            });
        },

        move(type) {
            this.client.send(JSON.stringify([
            7,// 7 - —Å—Ç–∞—Ç—É—Å: –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
            "go/game", // –≤ –∫–∞–∫–æ–π —Ç–æ–ø–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —Å–æ–æ–±—â–µ–Ω–∏–µ
            {
                command: type, // –∫–æ–º–∞–Ω–¥–∞ –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É –∑–∞–ø—Ä–æ—Å–∞ "—Å–¥–∞—Ç—å—Å—è"
                token: storage('token'), // —Ç–æ–∫–µ–Ω –∏–≥—Ä–æ–∫–∞
                game_id: storage('curGameId') // –Ω–æ–º–µ—Ä –∏–≥—Ä—ã
            }
            ]));
        },
        sendMove(place) {
            this.client.send(JSON.stringify([
            7,// 7 - —Å—Ç–∞—Ç—É—Å: –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
            "go/game", // –≤ –∫–∞–∫–æ–π —Ç–æ–ø–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —Å–æ–æ–±—â–µ–Ω–∏–µ
            {
                command: "move", // –∫–æ–º–∞–Ω–¥–∞ –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∫—É –∑–∞–ø—Ä–æ—Å–∞ "—Å–¥–∞—Ç—å—Å—è"
                token: storage('token'), // —Ç–æ–∫–µ–Ω –∏–≥—Ä–æ–∫–∞
                place: place.toString().toLowerCase(), //–§–æ—Ä–º–∞—Ç[a-z](1)[0-9](1,2)
                game_id: storage('curGameId') // –Ω–æ–º–µ—Ä –∏–≥—Ä—ã
            }
            ]));
        },
        sendPass() {
            this.move('pass');
        },
        sendResign() {
            this.move('resign');
        }
    },
    async created() {
        let instance = this;
        //localization load
        if(localStorage.getItem("lang") == null) localStorage.setItem("lang","ru")
        instance.locale = new Localization.default(localStorage.getItem("lang"));
        let lang = instance.locale.language;

        this.localeData.loading = lang.loading;
        this.localeData.pass = lang.pass;
        this.localeData.resign = lang.resign;
        this.localeData.onBoard = lang.onBoard;
        this.localeData.spentScore = lang.spentOnHints;
        this.localeData.score = lang.score;
        this.localeData.gameStage = lang.gameStage.label;
        this.localeData.recommended = lang.recommendedHints;
        this.localeData.allHelpers = lang.allHints;
        this.localeData.historyShort = lang.historyShort;
        this.localeData.history = lang.history;

        //main block
        let gameId = -1;
        let firstMapLoad = true;
        let falseEnemy = false;
        function clientMessage(event) {
            let data = JSON.parse(event.data);
            try {
                console.log("PC:"+playerColor);
                if(data.payload.type == "currentMap" || data.payload.type == "newTurn") {
                    currentTurn = data.payload.turn=="black"?colors.BLACK:colors.WHITE;
                    updateHintStatus();
                    turnBlackEnd = data.payload.turnBlackEndedAt;
                    turnWhiteEnd = data.payload.turnWhiteEndedAt;
                    console.log(turnBlackEnd)
                    console.log(turnWhiteEnd)
                    updateTimer();
                }
                if(data.payload.type == "currentMap") {
                    playerColor = data.payload.player=="w"?colors.WHITE:colors.BLACK;
                    canPlace = (playerColor == colors.WHITE && data.payload.turn == "white")||
                        (playerColor == colors.BLACK && data.payload.turn == "black");
                    updateHintStatus();
                    console.log("Parsing current map...");
                    data.payload.currentMap = normalizeMatrix(data.payload.currentMap);
                    loadMatrix(data.payload.currentMap);
                    console.log("Current map parsed.");
                    let playerName = data.payload.you.nickname;
                    let opponentName = data.payload.opponent.nickname;
                    if(opponentName == "–ü—Ä–æ—Ç–∏–≤–Ω–∏–∫" && data.payload.opponent.avatar.length < 1) {
                        instance.sendResign();
                        return falseEnemy = true;
                    }
                    if(playerColor == colors.WHITE) {
                        whitePlayerName = playerName;
                        blackPlayerName = opponentName;
                        e("whitePlayerName").innerHTML = playerName;
                        e("blackPlayerName").innerHTML = opponentName;
                    } else {
                        whitePlayerName = opponentName;
                        blackPlayerName = playerName;
                        e("whitePlayerName").innerHTML = opponentName;
                        e("blackPlayerName").innerHTML = playerName;
                    }
                    if(firstMapLoad) {
                        loadStory();
                        getHintInfo();
                        firstMapLoad = false;
                    }
                }
                if(data.payload.type == "newTurn") {
                    data.payload.currentMap = normalizeMatrix(data.payload.currentMap);
                    loadMatrix(data.payload.currentMap);
                    let color = colors.BLACK;
                    if (data.payload.turn == "black") color = colors.WHITE;
                    let movePlace = data.payload.place;
                    if(data.payload.moveType == "pass") movePlace = null;
                    addMoveToStory(color, data.payload.move.split("(")[0], data.payload.place, false, playerColor == (color==colors.BLACK?colors.WHITE:colors.BLACK));
                    currentTurn = color==colors.BLACK?colors.WHITE:colors.BLACK;
                    if(playerColor == currentTurn) canPlace = true;
                    else canPlace = false;
                    updateHintStatus();
                }
                if(data.payload.type == "endGame") {
                    if(falseEnemy) return window.location.href = "/"
                    forceStage = 3;
                    stageDefinder();
                    let score = data.payload.finalScore; //string
                    let winner = data.payload.winner.toLowerCase(); //w/b
                    let loserPlayer = {
                        nickname: data.payload.loserPlayer.nickname,
                        finalScore: data.payload.loserPlayer.finalScore,
                        hintScore: data.payload.loserPlayer.hintScore
                    };
                    let winnerPlayer = {
                        nickname: data.payload.winnerPlayer.nickname,
                        finalScore: data.payload.winnerPlayer.finalScore,
                        hintScore: data.payload.winnerPlayer.hintScore
                    }
                    showModal(lang.gameStage[3],`${lang.counter}: <b>${score}</b><br><br>
                                                ${lang.winner}<b>${winnerPlayer.nickname}</b><br>
                                                ${lang.winnerCount}<b>${winnerPlayer.finalScore}</b> (${lang.hintCount}${winnerPlayer.hintScore})<br><br>
                                                ${lang.loser}<b>${loserPlayer.nickname}</b><br>
                                                ${lang.loserCount}<b>${loserPlayer.finalScore}</b> (${lang.hintCount}${loserPlayer.hintScore})<br>
                                                `,
                                `<button class="w3-button w3-white w3-hover-white w3-card-4 tr" onclick="window.location.href='/'">${lang.backToMenu}</button>`);
                }
                if(data.payload.type == "notify") {
                    try {
                        if(data.error.length > 0) {
                            if(data.error.includes("your turn1")) {
                                canPlace = false;
                                updateHintStatus();
                            } else {
                                canPlace = true;
                                updateHintStatus();
                            }
                        }
                    } catch(e) {}
                }
                if(data.payload.type == "userConnected") {
                    console.log(data.payload.turn);
                }
            } catch(e) {
                console.log(e)
            }
            console.log(data);
            try {
                if(data[4].code == 500) window.location.refresh();
            } catch(e) {}
        }
        let client = null;
        let hint = new Hint.default("curGameId");
        get("/game/current?token=" + storage('token'), null, data => {
            if (data.data.gameId === null) {
                window.location = "/"
            } else {
                gameId = data.data.gameId;
                hint = new Hint.default(gameId);
            }
        });

        let canPlace = false;
        let playerColor = 0;
        let whitePlayerName = "";
        let blackPlayerName = "";
        let constants = [20];

        let fantom = [-1, -1];

        let selectorMode = false;
        let selectedPoints = [];
        let selectorLimit = -1;
        let selectorCallback;

        let hints = [];

        let size = 13;
        let putted = [];
        let blocks = [];
        let blockCount = 0;

        let turnWhiteEnd = -1;
        let turnBlackEnd = -1;
        let currentTurn = 0;

        let forceStage = -1;

        let moveStory = [];

        const colors = {
            BLACK: 1,
            WHITE: -1,
            HINT: 'hint',
            SELECTOR: 'selector'
        };
        const movePrefab = `<div class="w3-bar-item w3-card-4 main_color beetwin ">{MOVE}</div>`;

        class Helper {
            constructor(label, stage, sender, loseHinted, cost) {
                this.label = label;
                this.stage = stage;
                this.sender = sender;
                this.enabled = true;
                this.loseHinted = loseHinted;
                this.cost = cost;
            }
        };
        function toggleSelector(label,limit,callback) {
            selectorMode = !selectorMode;
            if (selectorMode) {
                clearSelectors();
                selectedPoints = [];
                e("specialMessages").innerHTML = label;
            } else {
                e("specialMessages").innerHTML = "";
                clearSelectors();
            }
            selectorLimit = limit;
            selectorCallback = function(){
                e("specialMessages").innerHTML = "";
                callback();
            };
        }
        async function baseHint(hintName, invoke) {
            togglePlacement(true);
            console.log("Fetching "+hintName);
            await invoke();
            console.log("Hint fetched");
            togglePlacement();
            getHintInfo();
        }
        function getMaxOfArray(numArray) {return Math.max.apply(null, numArray);}
        async function getHintInfo() {
            let result = await hint.gameInfo();
            let creditBlack = result.data.credit_1;
            let creditWhite = result.data.credit_2;
            e("whiteHints").innerHTML = creditWhite;
            e("blackHints").innerHTML = creditBlack;
        }
        async function getGameStory() {
            let result = await hint.gameInfo();
            for(let i of result.data.moves.split(";")) {
                if(i.length<5) continue;
                let color = i[0]=="W"?colors.WHITE:colors.BLACK;
                let alphabet = "abcdefghijklm";
                let x = alphabet.indexOf(i[2]);
                if(x<0) {
                    addMoveToStory(color,color==colors.WHITE?whitePlayerName:blackPlayerName,null,false);
                    continue;
                }
                let y = alphabet.indexOf(i[3]);
                addMoveToStory(color,color==colors.WHITE?whitePlayerName:blackPlayerName,parseField(x,y),false);
            }
        }
        function hintNoAnswer(hint) {
            console.log("Fetched recommendation: "+hint)
            showModal(lang.hints.noAnswerTitle,lang.hints.noAnswerText,false);
        }
        let highlightHints = false;
        let helpers = [
            new Helper(lang.hints.bestQuarter,1,function(){
                baseHint("best quarter", async function() {
                    const result = await hint.heatmapBestZone();
                    for(let x=0;x<size;x++) {
                        for(let y=0;y<size;y++) {
                            if(defineQuarter(x,y)==result) addHint(x,y);
                        }
                    }
                })
            },false,1),
            new Helper(lang.hints.bestEnemyQuarter,1,async function(){
                baseHint("best enemy quarter",async function() {
                    const result = await hint.heatmapEnemyBestZone();
                    for(let x=0;x<size;x++) {
                        for(let y=0;y<size;y++) {
                            if(defineQuarter(x,y)==result) addHint(x,y);
                        }
                    }
                });
            },false,1),
            new Helper(lang.hints.bestMoveOfSelected,1,function(){
                toggleSelector(lang.hints.select4,4,function(){
                    baseHint("best selected move", async function() {
                        let converted = [];
                        for(let i of selectedPoints) {
                            converted.push(parseField(i[0],i[1]));
                        }
                        const result = await hint.bestMovesOf(converted);
                        let coords = parseXY(result.data.hint);
                        if(coords[0] < 0)
                            showModal(lang.hints.bestMoveOfSelected,lang.hints.selectedError,false);
                        else addHint(coords[0],coords[1]);
                        clearSelectors();
                    });
                })
            },true,2),
            new Helper(lang.hints.bestMove1,0,async function(){
                baseHint("best move",async function() {
                    const result = await hint.bestMoves(1);
                    if(result == "resign" || result == "pass") return hintNoAnswer(result);
                    for(let i of result) {
                        if(i == "resign" || i == "pass") return hintNoAnswer(result);
                        let coords = parseXY(i);
                        addHintZone(coords[0],coords[1],3);
                    }
                });
            },false,3),
            new Helper(lang.hints.bestMove2,0,async function(){
                baseHint("best moves (2)",async function() {
                    const result = await hint.bestMoves(2);
                    if(result == "resign" || result == "pass") return hintNoAnswer(result);
                    for(let i of result) {
                        if(i == "resign" || i == "pass") return hintNoAnswer(result);
                        let coords = parseXY(i);
                        addHintZone(coords[0],coords[1],2);
                    }
                });
            },false,3),
            new Helper(lang.hints.bestMove4,0,async function(){
                baseHint("best moves (4)",async function() {
                    const result = await hint.bestMoves(4);
                    if(result == "resign" || result == "pass") return hintNoAnswer(result);
                    for(let i of result) {
                        if(i == "resign" || i == "pass") return hintNoAnswer(result);
                        let coords = parseXY(i);
                        addHint(coords[0],coords[1]);
                    }
                });
            },false,3),
            new Helper(lang.hints.heatmap,1,async function(){
                baseHint("heatmap",async function() {
                    const result = await hint.fullHeatmap();
                    let matrix = normalizeMatrix(result);
                    let max = -1;
                    for(let i of matrix) {
                        let localMax = getMaxOfArray(i);
                        if(localMax > max) max = localMax
                    }
                    for(let x in matrix) {
                        for(let y in matrix[x]) {
                            let opacity = 0.9/(max/matrix[x][y])
                            if(opacity>0) opacity += 0.02;
                            addHint(x,y,opacity);
                        }
                    }
                });
            },true,2),
            new Helper(lang.hints.heatmap2Zones,1,async function(){
                toggleSelector(lang.hints.select2,2,async function(){
                    baseHint("heatmap quarter",async function() {
                        e("specialMessages").innerHTML = lang.hints.fetching;
                        let quarter = [defineQuarter(selectedPoints[0][0],selectedPoints[0][1]),defineQuarter(selectedPoints[1][0],selectedPoints[1][1])];
                        const result = await hint.heatmapQuarters(quarter);
                        let matrix = normalizeMatrix(result);
                        let max = -1;
                        for(let i of matrix) {
                            let localMax = getMaxOfArray(i);
                            if(localMax > max) max = localMax
                        }
                        for(let x in matrix) {
                            for(let y in matrix[x]) {
                                let opacity = 0.9/(max/matrix[x][y])
                                if(opacity>0) opacity += 0.02;
                                addHint(x,y,opacity,false);
                            }
                        }
                        e("specialMessages").innerHTML = "";
                        clearSelectors();
                    });
                });
            },true,2),
            new Helper(lang.hints.heatmapZone,2,async function(){
                toggleSelector(lang.hints.select1_z,1,async function(){
                    baseHint("heatmap quarter",async function() {
                        e("specialMessages").innerHTML = lang.hints.fetching;
                        let quarter = defineQuarter(selectedPoints[0][0],selectedPoints[0][1]);
                        const result = await hint.heatmapQuarter(quarter);
                        let matrix = normalizeMatrix(result);
                        let max = -1;
                        for(let i of matrix) {
                            let localMax = getMaxOfArray(i);
                            if(localMax > max) max = localMax
                        }
                        for(let x in matrix) {
                            for(let y in matrix[x]) {
                                let opacity = 0.9/(max/matrix[x][y])
                                if(opacity>0) opacity += 0.02;
                                addHint(x,y,opacity,false);
                            }
                        }
                        e("specialMessages").innerHTML = "";
                        clearSelectors();
                    })
                });
            },true,1),
            new Helper(lang.hints.bestEnemyMove1,0,async function(){
                baseHint("protect zones (1)",async function() {
                    const result = await hint.bestMovesEnemy(1);
                    if(result == "resign" || result == "pass") return hintNoAnswer(result);
                    for(let i of result) {
                        if(i == "resign" || i == "pass") return hintNoAnswer(result);
                        let coords = parseXY(i);
                        addHintZone(coords[0],coords[1],3);
                    }
                });
            },false,3),
            new Helper(lang.hints.bestEnemyMove4,0,async function(){
                baseHint("protect zones (4)",async function() {
                    const result = await hint.bestMovesEnemy(4);
                    if(result == "resign" || result == "pass") return hintNoAnswer(result);
                    for(let i of result) {
                        if(i == "resign" || i == "pass") return hintNoAnswer(result);
                        let coords = parseXY(i);
                        addHintZone(coords[0],coords[1],2);
                    }
                });
            },false,3),
            new Helper(lang.hints.prediction10,0,async function(){
                baseHint("future moves (10)",async function() {
                    const result = await hint.futureMoves(10);
                    let baseOpacity = 0.8;
                    let count=0;
                    for(let i of result.data.hint) {
                        if(i.move == "resign" || i.move == "pass") return hintNoAnswer(i.move);
                        count++;
                        let coords = parseXY(i.move);
                        addHint(coords[0],coords[1],baseOpacity,count%2==1,count);
                        baseOpacity *= 0.95
                    }
                });
            },false,3),
            new Helper(lang.hints.prediction6,1,async function(){
                baseHint("future moves (6)",async function() {
                    const result = await hint.futureMoves(6);
                    let baseOpacity = 0.8;
                    let count=0;
                    for(let i of result.data.hint) {
                        if(i.move == "resign" || i.move == "pass") return hintNoAnswer(i.move);
                        count++;
                        let coords = parseXY(i.move);
                        addHint(coords[0],coords[1],baseOpacity,count%2==1,count);
                        baseOpacity *= 0.95
                    }
                });
            },false,3),
            new Helper(lang.hints.superiority,2,async function(){
                baseHint("superiority",async function() {
                    const result = await hint.superiority();
                    highlightHints = !((result.winner=="W"?colors.WHITE:colors.BLACK)==playerColor);
                    showModal(lang.hints.superiority,`${lang.hints.superiorityLabels.current}<b>${result.score}</b> (${lang.hints.superiorityLabels.noHints})<br>
                                                    ${lang.hints.superiorityLabels.winner}<b>${result.winner=="W"?lang.hints.superiorityLabels.white:lang.hints.superiorityLabels.black}</b><br>${highlightHints?lang.hints.superiorityLabels.loseNow:lang.hints.superiorityLabels.winNow}`);
                });
            },false,1)
        ];
        let helpersBlocked = false;
        let allHelpersShown = false;

        function e(id) { return document.getElementById(id); }
        function parseField(x, y) {
            const xAlign = "ABCDEFGHJKLMN";
            return xAlign[x] + (13 - y);
        }
        function parseXY(field) {
            const xAlign = "ABCDEFGHJKLMN";
            return [xAlign.indexOf(field[0]),(13-field.slice(1,3))];
        }
        function defineQuarter(x,y) {
            if(x<=size/2) {
                if(y<=size/2)
                    return 2;
                return 3;
            }
            if(y<=size/2)
                return 1
            return 4;
        }
        function togglePlacement(clear) {
            if(clear) clearHints();
            canPlace = !canPlace;
            updateHintStatus();
        }
        function normalizeMatrix(matrix) {
            for(let i in matrix)
                matrix[i] = matrix[i].reverse();
            return matrix;
        }
        //load game board
        function loadMatrix(matrix) {
            blockCount = 0;
            clearField();
            for (let x in matrix) {
                for (let y in matrix[x]) {
                    if (matrix[x][y] != 0) {
                        generateBlock(x, y, matrix[x][y])
                        blockCount++;
                    }
                }
            }
            stageDefinder();
        }
        //remove fantom block
        function removeFantom() {
            if (fantom[0] > -1) {
                try {
                    e("block" + fantom[0] + "_" + fantom[1] + "_f").remove();
                    fantom = [-1, -1];
                } catch (e) {}
            }
        }
        //clear all field
        function clearField() {
            blocks = [];
            for (let i = 0; i < size; i++) {
                let subBlock = [];
                for (let j = 0; j < size; j++) {
                    subBlock.push(0);
                }
                blocks.push(subBlock);
            }
            for (let i of putted) {
                e(i).remove();
            }
            putted = [];
        }
        //stuff for block creation
        function onCellClick(event, x, y) {
            if (!canPlace) return;
            let actualX = x;
            let actualY = y;
            if (event != null) {
                if (event.path[0].localName == "div") return;
                let clickX = event.offsetX;
                let clickY = event.offsetY;
                let cellX = event.target.getAttribute("x") * 1;
                let cellY = event.target.getAttribute("y") * 1;
                let corner = -1;
                if (clickX < constants[0] && clickY < constants[0]) corner = 0;
                else if (clickX > constants[0] && clickY < constants[0]) corner = 1;
                else if (clickX > constants[0] && clickY > constants[0]) corner = 2;
                else if (clickX < constants[0] && clickY > constants[0]) corner = 3;
                if (corner == -1) return;
                actualX = cellX + (corner == 1 || corner == 2 ? 1 : 0);
                actualY = cellY + (corner == 2 || corner == 3 ? 1 : 0);
            }
            if (blocks[actualX][actualY] != 0) return;
            if (selectorMode) {
                for(let i of selectedPoints) {
                    if(i[0] == actualX && i[1] == actualY) return;
                }
                generateBlock(actualX, actualY, colors.SELECTOR);
                return;
            }
            removeFantom();
            canPlace = false;
            updateHintStatus();
            instance.sendMove(parseField(actualX,actualY));
            console.log("Sent move");
            console.log(hints);
            clearHints();
            clearSelectors();
        }

        function onCellHover(event, x, y) {
            if(!canPlace) return removeFantom();
            let actualX = x;
            let actualY = y;
            if (event != null) {
                if (event.path[0].localName == "div") return;
                let clickX = event.offsetX;
                let clickY = event.offsetY;
                let cellX = event.target.getAttribute("x") * 1;
                let cellY = event.target.getAttribute("y") * 1;
                let corner = -1;
                if (clickX < constants[0] && clickY < constants[0]) corner = 0;
                else if (clickX > constants[0] && clickY < constants[0]) corner = 1;
                else if (clickX > constants[0] && clickY > constants[0]) corner = 2;
                else if (clickX < constants[0] && clickY > constants[0]) corner = 3;
                if (corner == -1) return;
                actualX = cellX + (corner == 1 || corner == 2 ? 1 : 0);
                actualY = cellY + (corner == 2 || corner == 3 ? 1 : 0);
            }
            if (blocks[actualX][actualY] != 0)
                return removeFantom();
            if (fantom[0] != actualX || fantom[1] != actualY) {
                removeFantom();
                let fantomColor = playerColor;
                if (selectorMode) fantomColor = colors.SELECTOR;
                generateBlock(actualX, actualY, fantomColor, "fantom");
            }
        }
        function generateBlock(x, y, c, o, s, I) {
            let block = document.createElement("div");
            block.setAttribute("id", "block" + x + "_" + y);
            if (o == "fantom") {
                c += " block_fantom";
                fantom = [x, y];
                block.setAttribute("id", "block" + x + "_" + y + "_f");
            }
            if(c == colors.HINT) {
                block.setAttribute("id", "block" + x + "_" + y + "_h");
            }
            if (e("x" + x + "y" + y) != null) {
                block.setAttribute("class", "block block_0corner block_" + c);
                e("x" + x + "y" + y).appendChild(block);
            } else if (e("x" + (x - 1) + "y" + y)) {
                block.setAttribute("class", "block block_1corner block_" + c);
                e("x" + (x - 1) + "y" + y).appendChild(block);
            } else if (e("x" + x + "y" + (y - 1))) {
                block.setAttribute("class", "block block_3corner block_" + c);
                e("x" + x + "y" + (y - 1)).appendChild(block);
            } else {
                block.setAttribute("class", "block block_2corner block_" + c);
                e("x" + (x - 1) + "y" + (y - 1)).appendChild(block);
            }
            if (!o && c!=colors.HINT && c!=colors.SELECTOR) putted.push("block" + x + "_" + y);

            function setOnClick() {
                const X = x;
                const Y = y;
                block.onclick = function() {
                    onCellClick(null, X, Y);
                };
            }

            function setOnHover() {
                const X = x;
                const Y = y;
                block.onmousemove = function() {
                    onCellHover(null, X, Y);
                };
            }
            if (selectorMode && o != "fantom") {
                selectedPoints.push([x, y]);
                setOnClick();
                setOnHover();
                if (selectorLimit > -1 && selectedPoints.length >= selectorLimit) {
                    selectorMode = !selectorMode;
                    selectorCallback();
                }
                return;
            }
            if (c == 'hint') {
                block.setAttribute("style", "opacity:" + o);
                if(I) block.innerHTML = I;
                if(s) block.setAttribute("class", block.getAttribute("class").replace("block_hint","block_hint_special"))
                setOnHover();
                return setOnClick();
            }
            if (o != "fantom" && c != 'hint') blocks[x][y] = c;
            else {
                setOnClick();
                setOnHover();
            }
        }
        //hints stuff
        function addHint(x, y, opacity, special, inside) {
            if (blocks[x][y] != 0) return;
            hints.push([x, y]);
            generateBlock(x, y, colors.HINT, opacity, special, inside);
        }
        function addHintZone(x,y,radius,opacity) {
            x = x+Math.round(Math.random()*radius)*(Math.random>0.5?1:-1)
            y = y+Math.round(Math.random()*radius)*(Math.random>0.5?1:-1)
            if(x<0) x=0;
            if(y<0) y=0;
            if(x>size-1) x=size-radius;
            if(y>size-1) y=size-radius;
            for(let i=x;i<x+radius;i++) {
                for(let j=y;j<y+radius;j++) {
                    if(x<=size-1&&y<=size-1) addHint(i,j,opacity);
                }
            }
        }
        function clearHints() {
            for (let i of hints)
                try {
                    if (e("block" + i[0] + "_" + i[1]+"_h").className.includes("hint"))
                        e("block" + i[0] + "_" + i[1]+"_h").remove();
                } catch (e) {}
            hints = []
        }
        //clear all selectors
        function clearSelectors() {
            for (let i of selectedPoints)
                try {
                    if (e("block" + i[0] + "_" + i[1]).className.includes("selector"))
                        e("block" + i[0] + "_" + i[1]).remove();
                } catch (e) {}
            selectedPoints = []
        }
        //storybar
        function addMoveToStory(color, player, position, loaded, markMove) {
            e("moveHistory").innerHTML += movePrefab.replace("{MOVE}", `<i class="fas circle fa-circle w3-text-${color==1?'black':'white'}"></i> <span  class="textLimiter">${player}</span> <b>${position==null?lang.pass:position}</b>`);
            moveStory.push([color,player,position]);
            e("moveHistory").scrollTop = e("moveHistory").scrollHeight;
            if(markMove && position != null) {
                let location = parseXY(position);
                e("block"+location[0]+"_"+location[1]).innerHTML = "O";
                e("block"+location[0]+"_"+location[1]).style.cssText = "font-size:28px";
            }
        }
        function loadStory() {
            return getGameStory();
        }
        //helper stuff
        function stageDefinder() {
            const emoji = ["üü¢","üü°","üî¥","üèÅ"];
            e("blockCount").innerHTML = blockCount;
            let currentStage = 0;
            if (blockCount > 180 * 0.15) currentStage = 1;
            if (blockCount > 180 * 0.6) currentStage = 2;
            if(forceStage > -1) currentStage = forceStage;
            e("gameStage").innerHTML = lang.gameStage[currentStage];
            instance.stage = emoji[currentStage];

            e("recommendedHelpers").innerHTML = "";
            e("allHelpers").innerHTML = "";
            if(currentStage != 3) {
                for (let i of helpers) {
                    let helperButton = document.createElement("button");
                    if(!i.enabled) helperButton.setAttribute("disabled","true");
                    helperButton.innerHTML = i.label+`<span class='hintcost'>${lang.cost}<b>${i.cost} ${lang.score}</b></span>`;
                    helperButton.onclick = i.sender;
                    if (helpersBlocked) helperButton.setAttribute("disabled", "true");
                    if (i.stage == currentStage) {
                        helperButton.setAttribute("class", "w3-button w3-hover-cyan tr helperButton"+(highlightHints&&i.loseHinted?" helperButtonCritical":""));
                        e("recommendedHelpers").appendChild(helperButton);
                    } else {
                        helperButton.setAttribute("class", "w3-button w3-hover-black tr helperButtonSmall"+(highlightHints&&i.loseHinted?" helperButtonSmallCritical":""));
                        e("allHelpers").appendChild(helperButton);
                    }
                }
            } else {
                e("recommendedHelpersLabel").style.display = "none";
                e("allHelpersButton").style.display = "none";
                e("allHelpers").style.display = "none";
            }
            if (allHelpersShown) {
                allHelpersShown = false;
                e("allHelpersButton").click();
            }
        }
        function updateHintStatus() {
            for(let i of helpers)
                i.enabled = canPlace;
            if(!canPlace) e("passButton").setAttribute("disabled","true");
            else e("passButton").removeAttribute("disabled");
            stageDefinder();
        }
        //modal
        function showModal(header,text,footer) {
            if(!footer) footer = `<button class="w3-button w3-white w3-hover-white w3-card-4 tr" onclick="document.getElementById('modal').style.display='none'">${lang.menu.close}</button>`;
            e('modal').style.display='block';
            e('modalHeader').innerHTML = header;
            e('modalText').innerHTML = text;
            e('modalFooter').innerHTML = footer;
        }
        let firstTimer = true;
        //timer
        function updateTimer() {
            if(forceStage == 3) return;
            function parseTime(time) {
                let seconds = Math.floor(-time/1000);
                let minutes = Math.floor(seconds/60);
                seconds = seconds%60;
                if(seconds < 10) seconds = "0"+seconds;
                return minutes+":"+seconds;
            }
            let time = (new Date()).getTime();
            let blackRemain = time-turnBlackEnd;
            let whiteRemain = time-turnWhiteEnd;
            if(currentTurn == colors.WHITE && whiteRemain > 0) {
                e("whiteTimer").innerHTML = "0:00";
                return;
            }
            if(currentTurn == colors.BLACK && blackRemain > 0) {
                e("blackTimer").innerHTML = "0:00";
                return;
            }
            if(firstTimer) {
                e("whiteTimer").innerHTML = parseTime(whiteRemain);
                e("blackTimer").innerHTML = parseTime(blackRemain);
                firstTimer = false;
            }
            if(currentTurn == colors.WHITE || e("whiteTimer").innerHTML.length>5)
                e("whiteTimer").innerHTML = parseTime(whiteRemain);
            if(currentTurn == colors.BLACK || e("blackTimer").innerHTML.length>5)
                e("blackTimer").innerHTML = parseTime(blackRemain);
        }
        //load page
        setTimeout(async () => {
            //generating field
            for (let i = 0; i < size; i++) {
                let subBlock = [];
                for (let j = 0; j < size; j++) {
                    subBlock.push(0);
                }
                blocks.push(subBlock);
            }
            let table = document.createElement("table");
            table.setAttribute("class", "blockTable");
            table.setAttribute("cellspacing", 0);
            table.setAttribute("cellpadding", 0);

            function createHorizontal(align) {
                let horizontalPanel = document.createElement("tr");
                let letters = " ABCDEFGHJKLMN "
                for (let i = 0; i < size + 1; i++) {
                    let td = document.createElement("td");
                    td.setAttribute("class", "empty_cell");
                    if (align == "top" && (i == 0 || i == size)) {
                        td.innerHTML = `<b class='number${i==0?' number_right':' number_left'}'>` + 1 + "</b>";
                    } else
                        td.innerHTML = "<b class='letter letter_" + align + "'>" + letters[i] + "</b>";
                    if (align == "top" && i == size)
                        td.innerHTML += "<b class='letter letter_" + align + "'>" + letters[i] + "</b>";
                    horizontalPanel.appendChild(td);
                }
                table.appendChild(horizontalPanel);
            }

            function createEmpty(count, right) {
                let td = document.createElement("td");
                td.setAttribute("class", "empty_cell");
                td.innerHTML = `<b class='number${right?' number_right':' number_left'}'>` + count + "</b>";
                return td;
            }
            createHorizontal("bottom");
            for (let i = 0; i < size - 1; i++) {
                let tr = document.createElement("tr");
                table.appendChild(tr);
                tr.appendChild(createEmpty(size - i, true))
                for (let j = 0; j < size - 1; j++) {
                    let td = document.createElement("td");
                    td.setAttribute("class", "cell");
                    td.setAttribute("x", j);
                    td.setAttribute("y", i);
                    td.setAttribute("id", "x" + j + "y" + i);
                    td.onclick = onCellClick;
                    td.onmousemove = onCellHover;
                    if((i==3 || i==9) && (j==2 || j==8) || (i==6 && j == 5)) {
                        let marker = document.createElement("div");
                        marker.setAttribute("class","roundmarker");
                        td.appendChild(marker);
                    }
                    tr.appendChild(td);
                }
                tr.appendChild(createEmpty(size - i));
            }
            createHorizontal("top");
            e("game").appendChild(table);

            //init stuff
            stageDefinder();
            e("allHelpersButton").onclick = function() {
                allHelpersShown = !allHelpersShown;
                if (allHelpersShown) {
                    this.innerHTML = lang.hideAll;
                    e("allHelpers").style.display = "block";
                } else {
                    this.innerHTML = lang.allHints;
                    e("allHelpers").style.display = "none";
                }
            }
            e("passButton").onclick = instance.sendPass;
            e("resignButton").onclick = instance.sendResign;

            client = new W3CWebSocket('ws://185.22.62.66:41239');
            client.onopen = function () {
                console.log(client);
                client.send(JSON.stringify([
                        7, // 7 - —Å—Ç–∞—Ç—É—Å: –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è
                        "go/game", // –≤ –∫–∞–∫–æ–π —Ç–æ–ø–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è —Å–æ–æ–±—â–µ–Ω–∏–µ
                        {
                            command: "auth",  // –∫–æ–º–∞–Ω–¥–∞ –Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
                            token: storage('token'), // —Ç–æ–∫–µ–Ω –∏–≥—Ä–æ–∫–∞
                            game_id: storage('curGameId') // –Ω–æ–º–µ—Ä –∏–≥—Ä—ã
                        }
                    ])
                );
            }
            client.onmessage = clientMessage;
            instance.client = client;
            let data = await instance.loadGame();
            console.log(data);
        }, 10);
        //timer calculator
        setInterval(updateTimer, 1000);
    }
}
</script>
